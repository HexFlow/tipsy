package tipsy.cluster

import scala.collection.mutable.{Map => mMap}

object Clusterify {

  def apply(matrixNetwork: List[List[Double]],forceNetwork: List[(Int, Int, Double)], length: Int, names: List[String], cluster: Int, equalSized: Boolean): Unit = {
    println("--------------")
    println("Matrix Network")
    println("--------------")
    println(matrixNetwork)
    println("-----")
    println("Names")
    println("-----")
    println(names)
/*    val mb = 1024*1024
    val runtime = Runtime.getRuntime
    println("** Used Memory:  " + (runtime.totalMemory - runtime.freeMemory) / mb)
    println("** Free Memory:  " + runtime.freeMemory / mb)
    println("** Total Memory: " + runtime.totalMemory / mb)
    println("** Max Memory:   " + runtime.maxMemory / mb)*/
    //val fastmaped = fastmap(matrixNetwork, length, 100)
    validateMatrixNetwork(matrixNetwork ,length)
    val kmeaned = kmeans(forceNetwork, length, names, cluster, 2, equalSized)
//    val dbscaned = dbscan(matrixNetwork, length, 0.299, 3)
  }

  def validateMatrixNetwork (matrixNetwork: List[List[Double]], length: Int): Unit = {
    var cnt = 0
    for (i <- 0 to length - 1) {
      for (j <- i + 1 to length - 1) {
        for (k <- j + 1 to length - 1) {
          val (a, b, c) = (matrixNetwork(i)(j), matrixNetwork(i)(k), matrixNetwork(j)(k))
          if (a + b < c) {
            print(s"** [error] triangle inequality not satisfied amongst: ($a($i, $j), $b($i, $k)) and $c($j, $k) ")
            println(a + b - c)
            cnt += 1
          }
          if (a + c < b) {
            print(s"** [error] triangle inequality not satisfied amongst: ($a($i, $j), $c($j, $k)) and $b($i, $k) ")
            println(a + c - b)
            cnt += 1
          }
          if (b + c < a) {
            print(s"** [error] triangle inequality not satisfied amongst: ($b($i, $k), $c($j, $k)) and $a($i, $j) ")
            println(b + c - a)
            cnt += 1
          }
        }
      }
    }
    println(cnt, length)
  }

  def fastmap(matrixNetwork: List[List[Double]], length: Int, dimOfVS: Int): (List[List[Double]], List[(Int, Int)]) = {
    val fastmaped = FastMap(matrixNetwork, length, dimOfVS)
    println("---------------")
    println("Projection In K")
    println("---------------")
    println(fastmaped._1)
    println("-----------------")
    println("Pivots in FastMap")
    println("-----------------")
    println(fastmaped._2)
    fastmaped
  }

  def dbscan(matrixNetwork: List[List[Double]], length: Int, eps: Double, minPts: Int): mMap[Int, (DBSCANPoint, Int)] = {
    val dbscaned = DBSCAN(matrixNetwork, length, eps, minPts)
    val clusters = Array.fill(length)(-1)
    for (i <- List.range(0, length)) {
      dbscaned get i match {
        case None =>
        case Some((NOISE, _)) => clusters(i) = -1
        case Some((_, cluster)) => clusters(i) = cluster
      }
    }
    println("----------------------------")
    println("Clusters generated by DBSCAN")
    println("----------------------------")
    println(clusters.toList)
    dbscaned
  }

  def kmeans(forceNetwork: List[(Int, Int, Double)], length: Int, names: List[String], clusters: Int, dimOfVS: Int, equalSized: Boolean): (List[List[Double]], List[Int]) = {
   // val fastmaped = fastmap(matrixNetwork, length, dimOfVS)
    val coordinates: List[List[Double]] = DMtoCM(forceNetwork, length, names)
   // println("-----------------------")
   // println("Coordinates For K-Means")
   // println("-----------------------")
   // println(coordinates)
    val kmeaned = KMeans(coordinates, length, dimOfVS, clusters, equalSized)
 //   println("--------------------")
 //   println("Centroids In K-Means")
 //   println("--------------------")
 //   println(kmeaned._1)
    println("-----------------------------")
    println("Clusters generated in K-Means")
    println("-----------------------------")
    println(kmeaned._2.zipWithIndex.map(a => (a._2, a._1)))
    kmeaned
  }

}
